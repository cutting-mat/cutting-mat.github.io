# 目录结构

## 模块化设计

CuttingMat 的目录结构是按业务拆分的模块化设计，非常适合多业务模块、多人协同开发的场景。当然，应对小型团队或小型项目更是不在话下。

整体目录结构如下：

``` js
|--public/ 
|--src/
|   |--__template/                  // 新模块模板
|   |--core/                        // 核心文件（框架）
|   |--main/                        // 主模块
|   |--system/                      // 子模块（内置系统管理）
|   |--user/                        // 子模块（内置个人中心）
|   |--App.vue                      // Vue 根组件
|   |--main.js                      // 构建入口
|   |--module.config.js             // 模块配置（框架）
|   |--request.config.js            // 请求配置（框架）
|   |--store.config.js              // Store 配置（框架）
|   |--upload.config.js             // 上传配置（框架）
|   ·--vue-global-resource.js       // Vue 全局功能注册（框架）
|--.browserslistrc              // 兼容性配置
|--.eslintrc                    // 代码检查配置
|--.gitignore                   // git 忽略配置
|--babel.config.js              // babel 配置
|--package.json                 // 项目描述
·--vue.config.js                // Vue-CLI 配置
```

除了眼熟的Vue-CLI标准模板文件，标注（框架）的文件是脚手架自身的功能实现和配置文件，忽略掉这些之后`src/`目录里只剩下一个主模块和两个子模块：

```js
src/
  |--main (主模块)
  |--system (子模块)
  |--user (子模块)
  |--……

```

这是框架的最主要特征：**以模块做为项目文件的基本组织单位**，根据业务模型，整个项目被拆分成物理意义上的一个主模块+若干子模块。

模块化的目录结构可以将开发者从大型项目的代码管理压力中解放出来，开发过程可以始终将关注点聚焦在当前模块文件夹内，将模块间的干扰降到最低。

## 主模块与子模块

每个模块都包含自己的 API、静态资源、组件、页面等文件，并且**模块必须输出自己的路由**。所谓主模块与子模块，实际上就是 Vue 中的路由与子路由的关系，主模块就是实现了根路由（`'/#/'`）的模块，子模块就是实现其他子路由的模块。

主模块与子模块通过模块配置文件（`@/module.config.js`）定义，被定义成子模块的路由会被自动挂载到根路由（`'/#/'`）的`children`节点，组成项目最终的路由。

以模块为单位的路由注册，天然实现了各业务模块的开发解耦，开发过程中各个模块通常只修改自己的文件，只要路由没有最终注册到项目中，就基本不会发生代码冲突。

模块的内部结构从技术上没有限制，但为了统一风格便于协作，我们约定模块目录结构如下：

``` js
    |--api/                             // 请求接口
    |   ·--user.js 
    |--assets/                          // 依赖
    |   |--img/
    |   |--style.css
    |   ·--util.js
    |--components/                      // 组件
    |   ·--myComponents.vue
    |--views/                           // 页面
    |   |--Index.vue
    |   ·--List.vue
    ·--index.js                         // 模块路由
```

模块内部的路由结构没有限制，但建议将从属于同一功能模块的页面由一个共同的主页组成[嵌套路由](https://router.vuejs.org/zh/guide/essentials/nested-routes.html)，便于实现主界面样式，以及在主页挂载 scopeClass，使用`.scopeClass >>> .moudleClass`语法实现模块级通用样式。

```js
/#/subMoudle/List
+------------------------+ 
| ./views/Index.vue      |
| +--------------------+ |
| | ./views/List.vue   | |
| |                    | |
| |                    | |
| +--------------------+ |
+------------------------+
```

更多路由相关内容，请参考[路由结构](./intro-routes)。

## 代码组织

各模块的物理分隔，实际上天然形成了一套模块级的命名空间，比如文件命名再也不用`xxx-list.vue`，对于一个简单的模块的列表文件直接命名为`List.vue`就好了，完全不用担心命名冲突。

合理利用这种模块化的目录特点，还可以很容易实现一套分层的代码组织结构。

资源引用
